// Convierte un elemento en un contenedor
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}

// Convierte un elemento en un row
@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}

/*
    Convierte un elemento en una columna del tamaño de $cols.
    Si durante la invocación del argumento no se pasa ningúno, las reglas se aplicarán al elemento, según el cual 
    se organizará como un elemento flexible y ocupará un espacio igual al espacio ocupado por los elementos vecinos 
    Si durante la invocación de argumentos se pasan ambos argumentos y el tipo del primer argumento es el número de $cols, y el segundo
    argumento corresponde a uno de los nombres de lod $grid-breakpoints, entonces solo se aplica la regla
    en una media querie cuyo valor se toma de este segundo argumento. Además, como el valor del segundo argumento 
    se debe usar uno de los nombres $grid-breakpoints. Si solo se pasa el primer argumento, 
    o el valor del segundo argumento no coincide con ninguno de los nombres de los $grid-breakpoints, 
    entonces el elemento solo ocupará el número de celdas, igual $cols
  */
@mixin col($cols: "false", $breakpoint: "false") {
  @if (
    $breakpoint !=
      "false" and
      map_has_key($grid-breakpoints, $breakpoint) and
      $cols !=
      "false" and
      type_of($cols) ==
      number
  ) {
    @media screen and(#{$media-query}-width: map-get($grid-breakpoints, $breakpoint)) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
      flex: 0 0 auto;
      box-sizing: border-box;
      margin: 0 $h-gutter / 2 $v-gutter;
    }
  } @else if
    ($breakpoint == "false" and $cols != "false" and type_of($cols) == number)
  {
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// Calcula el ancho de la columna en función del número de columnas pasadas $cols
@function col-width($cols: 1) {
  @return calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
}

/*
    Genera las columna con estas clases .col-1, .col-2, .col-3 etc. basado en la variable global 
    $columns - número de columnas de la grilla.
  */
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: col-width($i);
    }
  }
}

/*
    Genera las clases para las columnas en table .col-tablet-8 y reglas CSS para los media queries basada en 
    $cols - los números de las columnas, 
    $screen-width - ancho de la pantalla,
    $name - nombres de los breakpoints, 
    cuyo valor debe corresponder a uno de los nombres del objeto global $grid-breakpoints
  */
@mixin generate-breakpoint($cols, $screen-width, $name) {
  .col-#{$name}-#{$cols} {
    @media screen and (#{$media-query}-width: $screen-width) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter}) !important;
      flex: auto 0 0;
    }
  }
}

/*
  Genera las clases para las columnas y reglas CSS en los media queries con la variable global 
  $columns - número de columnas
  $grid-breakpoints - puntos de interrupción
*/
@mixin generate-grid-breakpoints(
  $cols: $columns,
  $breakpoints: $grid-breakpoints
) {
  @for $i from 1 through $cols {
    @each $name, $value in $breakpoints {
      @include generate-breakpoint($i, $value, $name);
    }
  }
}
